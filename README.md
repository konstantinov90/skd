required command:

`git config --global core.quotepath off`

Установка зависимостей:

`pip install -r requirements.txt`

Данное приложение представляет собой веб-сервис, выполняющий SQL проверки и Python скрипты пачками. Приложение построено на основе фреймворка [aiohttp](https://aiohttp.readthedocs.io/en/stable/).

Проверки берутся автоматически из git-репозиториев, перечисленных в поле `REPOS` в `settings.py` (файл можно скопировать из `settings_template.py`, подставив необходимые значения). Соответственно, для доступа к GIT используется модуль `gitpython` (он устанавливается вместе с другими зависимостями), но для его работы **скоре всего** требуется git-клиент (без него не проверял).

Также для работы приложения требуется БД Mongo. Строка подключения вписывается в поле `DATABASE` в `settings.py`. В базе документируются все пришедшие в СКД задания и проверки, а также метаданные результатов проверок.

Приложение запускается командой `python server.py`. Основной веб-сервер запускается на порту `PORT` из `settings.py`. Параллельно с основным запускаются вспомогательные веб-сервера (воркеры), на портах, перечисленных в `WORKER_PORTS` в `settings.py`. Будет запущено столько воркеров, сколько портов указано в данной настройке.

Данная архитектура выбрана в связи с тем, что периодчески находятся запросы или скрипты, желающие подвесить свой поток, и подморозить отзывчивость интерфейса.

# Рождение шаблонов проверок

Проверки впервые появляются в БД СКД при запуске сервера СКД. Проверки берутся из git-репозиториев, перечисленных в настройках сервера СКД (файл `settings.py`) в переменной `REPOS` типа `dict`. Ключи этого словаря интерпретируются как код системы, к которой относятся проверки из этого репо. Наименования каталогов в корне этих репо интерпретируются как наименования операций, к которым относятся проверки из этих каталогов . Наконец, к качестве проверок рассматривются только файлы с расширенями `.py`, `.yml`, `.sql` в этих каталогах. Иные файлы и каталоги в репозиториях игнорируются и на работу СКД не влияют, так что владельцы репо вольны хранить там вспомогательные файлы.

Таким образом, в БД СКД попадают документы следующей формы:

```
{
    "_id": ObjectId, // стандартный id документа, формируемый MongoDB
    "system": String, // код системы - наименование репо
    "operation": String, // код операции - наименование каталога в корне репо
    "name": String, // наименование проверки - наименование файла без расширения
    "extension": String, // тип проверки - расширение файла проверки, может принимать одно из трех значений [py|yml|sql]
    "hash": String, // hash-сумма содержимого (? не уверен, что только лишь содержимого) файла проверки, вычисляемая git'ом, для контроля изменений
    "key_path": String, // "ключевой путь" проверки, не что иное как объединение полей ${system}/${operation}/${name}.${extension}
    "content": String // полный текст содержимого файла проверки, собственно исполняемый код проверки
}
```

При дальнейшей работе сервера СКД происходит периодический pull из ветки master всех репозиториев (период задается в настройках, переменная `CACHE_REFRESH_SECONDS`). Все изменения (добавление новых проверок, удаление существующих проверок и изменения кода проверок) сразу же фиксируются в БД.

# Задание на выполнение проверки в СКД

POST на ${SKD_URL}/rest/send_task/

Ниже представлено тело запроса:

```
{
"system": "TSIII", // код системы
"operation": "CONSCALC",  //код операции
"key": { // дополнительные атрибуты проверки - произвольный набор полей, в том числе сложных (даты, объекты, массивы)
    "user": "konstantinov",
    "stand_name": "ts_black",
    "smth": "some_value",
    ...
 },
"sources": [  //для идентификации исходных данных - коннекты к БД, значения переменных, в т.ч. id исходных операций
    {
        "connection_string": "facts/***@ts_black", //строка подключения к БД Oracle
        "class_name": "OracleConnection", // говорим, что соединяемся с БД Oracle
        "ops": {
            "CONSCALC": 1442,
            "LOADPOWDEM": 56601,
            "CALENDAR": 56401,
            "LOADPREVDR": 62801
            // любой другой набор полей, включая даты (по смыслу это bind variables)
            // https://blogs.oracle.com/sql/improve-sql-query-performance-by-using-bind-variables
    }, {
        "connection_string": "host=vm-facts-db port=5432 dbname=facts user=facts password=***",
        "class_name": "PostgresConnection",
        "ops": {
            "CONSCALC": 1,
            "LOADPOWDEM": 2,
            "CALENDAR": 3,
            "LOADPREVDR": 4
        }
    }
],
"checks": [{"name": "наименование проверки1", "extension": "py"}]
// необязательное поле для указания конкретных проверок в рамках заданной операции
// если не задано - запустятся все проверки
 
}
```

Документ задания попадает в БД почти в неизменном виде, за исключением добавления нескольких полей:

```
{
    "_id": ObjectId, // стандартный id документа, формируемый MongoDB
    "started": Date // дата получения задания
}
```

# Рождение проверок после получения задания

При получении задания инициализируется выполнение всех проверок, которые попадают в фильтр:

```
{
    "system": task.system,
    "operation": task.operation,
    "name" + "extension": {$in: task.checks.name + task.checks.extension} if task.checks else any // не судите строго за псевдокод
    // идея в том, что если в задании передан необязательный массив checks - то выполняются проверки только из этого массива
    // иначе выполняются все проверки указанной операции
}
```

Таким образом, в БД рождаются фактические проверки (далее "проверки"), которые представляют собой объединение полей документов шаблонов проверок и полей документа задания. Документы выглядят так:

```
{
    "_id": ObjectId, // стандартный id документа, формируемый MongoDB
    "system": String, // код системы из шаблона проверки
    "operation": String, // код операции из шаблона проверки
    "name": String, // наименование проверки из шаблона проверки
    "extension": String, // тип проверки из шаблона проверки
    "hash": String, // hash-сумма содержимого из шаблона проверки
    "key_path": String, // "ключевой путь" проверки из шаблона проверки
    "task_id": ObjectId, // id документа задания, инициализировавшевого данную проверку
    "key": JSON, // поле key из задания
    "started": Date // время начала выполнения проверки
    "latest": boolean = true // при этом всем предыдущим проверкам этого шаблона с таким же ключом key данное поле приравнивается false - признак того, что данная проверка является последней в ряду себе подобных на конкретном стенде
    // далее идут поля, которые появляются в процессе жизни проверки, но первоначально отсутствуют
    "submitted_to": String, // URL web-воркера, на котором выполнялась/выполняется проверка
    "running": boolean, // признак того, выполняется ли в данный момент проверка (true), или уже выполнилась (false)
    "finished": Date, // время окончания выполнения проверки
    "result": JSON, // по конвенции ТЗ здесь должно быть значение типа boolean (частный случай JSON-объекта), но в общем случае это может быть любой объект, необязательное поле
    "result_filename": String, // наименование файла с результатами проверки, если файл формировался, необязательное поле
    "result_crc32": String // контрольная сумма crc32 файла с результатами, если файл формировался, необязательное поле
}
```

# Запросы на коллекции СКД

POST на ${SKD_URL}/rest/cache/ - коллекция шаблонов проверок

POST на ${SKD_URL}/rest/tasks/ - коллекция полученных заданий

POST на ${SKD_URL}/rest/checks/ - коллекция выполняемых/выполненных проверок

Предполагается, что эти endpoint позволяют делать запросы почти любой формы на вышеуказанные коллекции.

Допустим, мы хотим получить код первых 10и проверок, отсортированных по имени в алфавитном порядке, в системе BR, в операциях, в коде которых присутствует слово ВСВГО:

так бы это сделали в БД: 

```javascript
db.getCollection('cache')
  .find({ system: 'BR', operation: { $regex: 'ВСВГО' }, { _id: 0, key_path: 1, content: 1 } })
  .sort({ name: 1 })
  .limit(10)
```

А так - через АПИ СКД (в поле sort используем синтаксис `pymongo`)

```
{
    "query": {
        "system": "BR",
        "operation": {"$regex": "ВСВГО"}
    },
    "sort": [["name": 1]],
    "limit": 10,
    "project": {"_id": 0, "key_path": 1, "content": 1}
}
```

# Получение результатов последних выполненных проверок

POST на ${SKD_URL}/rest/get_last_checks/

```
{
    "query": {
        "system": String, // код системы
        "operation": String, // код операции
        "key": JSON // ключ задания
    },
    "response_hash": String // хэш-сумма ответа на предыдущий запрос, необязательное поле
}
```

Поле `response_hash` позволяет использовать механизм long-polling. При первичном запросе это поле следует оставить пустым. В полученном документе будет два поля: `data` - собственно данные, об этом ниже, и поле `response_hash` - со значением, равным хэш-сумме полученных данных. При последующих запросах следует передавать это значение, тогда результат будет возвращаться только при изменении запрашиваемых данных.

В поле `data` представлены как информация по шаблонам проверок, так и результаты выполнения проверок с совпадающим значением поля `key_path`, если таковые имеются, т.е. факт НЕинициализации проверки также зафиксирован в этих данных. Причем, в результаты попадают проверки с значением поля `latest = true`, то есть в данных будет не более одной проверки каждого шаблона.

тело ответа:

```
{
    "data": [
        { // JSON - шаблон проверки, без поля content
            "_id": ObjectId,
            "operation": String,
            "name": String,
            "extension": String,
            "hash": String, // *
            "key_path": String,
            "check": { // JSON - фактическая проверка, если существует
                "_id": ObjectId,
                "operation": String,
                "name": String,
                "extension": String,
                "hash": String, // это значение равно хэш-сумме шаблона проверки, которая фактически выполнялась, т.е. оно может отличаться от значения, помеченного выше звездочкой. Таким образом можно фиксировать факт изменения текста проверки после инициализации ее выполнения (протухшие проверки)
                "key_path": String,
                "task_id": ObjectId,
                "key": JSON,
                "started": Date,
                "latest": boolean,
                "submitted_to": String,
                "running": boolean,
                "finished": Date,
                "result": JSON,
                "result_filename": String,
                "result_crc32": String
            }
        },
        ...
    ],
    "response_hash": String
}
```

# Получение файлов с результатами проверок



За отдачу файлов с результатами проверок отвечает сервер nginx, настроенный на выдачу статических файлов из каталога СКД с результатами проверок

GET ${SKD_URL}/files/${check.filename}

где check.filename - это поле filename из документа check
